
// https://docs.rs/mockall/0.6.0/mockall/
// It can mock most traits, or structs that only have a single impl block. For things it can't handle, there is mock!.

#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unused_variables)]

use mockall::*;
use mockall::predicate::*;

//

// cargo test -- --show-output


// https://docs.rs/mockall/0.6.0/mockall/macro.mock.html

// https://docs.rs/crate/mockall_examples/0.7.2/source/src/lib.rs

// more
// https://github.com/kriomant/mockers
// https://www.lpalmieri.com/posts/2020-04-13-wiremock-async-http-mocking-for-rust-applications/

// https://users.rust-lang.org/t/mocking-library/5295
// https://github.com/kriomant/mockers

// https://github.com/asomers/mockall

// mockall


#[automock]
trait MyTrait {
    fn foo(&self, x: u32) -> u32;
}

fn call_with_four(x: &dyn MyTrait) -> u32 {
    x.foo(4)
}


fn getting_started_mockall() {
    //Getting Started
    
    let mut mock = MockMyTrait::new();
    
    mock.expect_foo()
        .with(predicate::eq(4))
        .times(1)
        .returning(|x| x + 1);

    assert_eq!(5, call_with_four(&mock));
}

/*********************************************************************/

// mock directly
// https://docs.rs/mockall/0.6.0/mockall/macro.mock.html
// Blick ich nich

/*
trait Fook {
    fn fook(&self, x: i32) -> i32;
}

mock!{
    pub MyStruct<T: Clone + 'static> {
        fn bar(&self) -> u8;
    }
    trait Fook {
        fn fook(&self, x: i32) -> i32;
    }
}

fn call_dafook(x: &Fook) -> i32 {
    x.fook(4)
}

fn get_started_mock() {
    //Getting Started
    
    let mut mock = MockMyStruct::new();
    
    mock.expect_fook()
        .with(predicate::eq(4))
        .times(1)
        .returning(|x| 99);

    assert_eq!(5, call_dafook(&mock));
}

*/
/*********************************************************************/


//
/*
#[automock]
trait Foo<T: 'static> {
    fn new(t: T) -> MockFoo<T>;
}

let ctx = MockFoo::<u32>::new_context();
ctx.expect()
    .returning(|_| MockFoo::default());
let mock = MockFoo::<u32>::new(42u32);
*/




fn dependency () -> i32 {
    5
}

fn function ( x:i32) -> i32 {
    dependency() + x
}

// https://docs.rs/mockall_examples/0.7.2/mockall_examples/


// A trait implemented by a Struct we want to mock
pub trait Bah {
    // Some trait method
    fn bah(&self);
}

mock! {
    // structs can be mocked with `mock!`
    //
    // Their mock methods have an identical API to the methods generated by
    // `#[automock]`
    pub Boo {
        // A method on a struct
        fn boo(&self);
    }
    // An implementation of a trait on a mocked struct
    trait Bah {
        fn bah(&self);
    }
}

fn examples() {

    //let Boo = ; ?????????ßß

//bah();
    
}


// https://stackoverflow.com/questions/55152927/how-to-mock-specific-methods-but-not-all-of-them-in-rust
// As you have already learned, you cannot replace methods on a type.
// The only thing you can do is move the methods to a trait and then
// provide production and test-specific implementations of that trait.
// How you structure the trait determines the granularity of what you are able to test.


trait SomeRng {
    fn random_number(&self) -> u64;

    fn plus_one(&self) -> u64 {
        self.random_number() + 1
    }
}

struct RngTest(u64);

// hier wird die funktion getauscht
impl SomeRng for RngTest {
    fn random_number(&self) -> u64 {
        self.0
    }
}


#[cfg(test)]
mod sometests {

    use super::*;
    
    #[test]
    fn plus_one_works() {
        let rng = RngTest(41);
        assert_eq!(rng.plus_one(), 42);
    }
}


fn stackover() {
    
    let rng = RngTest(41);
    assert_eq!(rng.plus_one(), 42);
    
}

/*********************************************************************/


// https://knowitlabs.no/rust-2020-testing-4ab3d80112ba

/*
 * Within my team it has been debated whether the best style is to
 exclusively depend on abstract interfaces, everywhere. My personal
 view is that this should be determined by the runtime intent. In high
 level languages this is usually no problem, because method dispatch is
 usually dynamic dy default. This means that any or most concrete types
 or classes are easily sub-classable, and thus the coupling to such a
 class by name is not really that strong under the hood. All
 python/Java/Kotlin/JS languages support this easily: Creating mocks of
 concrete types.
 */

/*
Higher order functions

If I want to test a function or procedure A in isolation that depends
on another function B, I can pass B as a parameter to A. In production
code I call A(B). In the test I call A(mocked_B), now with full
control over that dependency.

*/

/*
...
So the way to express an abstraction in Rust is to use a trait.
* Trait mocking in Rust today is fairly developer friendly, but not as
* friendly as in dynamic-dispatch-languages. What I’ve been doing so
* far is to introduce a new trait everywhere I need test isolation,
* and use the crate mockall to autogenerate a mocked implementation
* that I instantiate in my test. Not very far from how java/mockito or
* jest works, except that, as mentioned, we always need to be very
* explicit about the abstraction taking place:

*/

//#[cfg_attr(test, mockall::automock)]

#[automock]
trait SomethingIWantToMock {
    fn mockable(&self);
    fn mockme(&self, i:i32)-> i32;
}

struct ConcreteSomethingUsedInProduction {}

impl SomethingIWantToMock for ConcreteSomethingUsedInProduction {
    //fn mockable() { ... }

    fn mockable(&self) {
        println!("Called mockable");
    }

    fn mockme(&self, i:i32 ) -> i32 {
        println!("Called mockme with {}", i);
        self.mockable();
        println!("Returning {}", 77);
        return 77
    }
}



//#[test]
fn test_something() {
    println!("Starting ... ");

    let conc = ConcreteSomethingUsedInProduction{};

    conc.mockable();
    conc.mockme(44);

    let mut mock_something = MockSomethingIWantToMock::new();
    // test some code using that dependency


    //let mut mock = MockMyTrait::new();
    //mock.expect_foo()
    //    .with(predicate::eq(4))
    //    .times(1)
    //    .returning(|x| x + 1);
    //assert_eq!(5, call_with_four(&mock));

    mock_something.expect_mockme() // no parameters
        .with(predicate::eq(10))
        .times(1)
        .returning(|x| x + 11);
    
    println!("Calling Mock ... ");

    assert_eq!(21, mock_something.mockme(10) );

    println!("Ending ... ");
    
}

/*
* In Rust, making code dynamic dispatch is less verbose than making
* it static dispatch. This is in some ways counterintuitive, because
* in other areas of the language it appears to be a concious decision
* that less verbose code is simpler and therefore more efficient. Heap
* allocation is one example, it is always very apparent that a heap
* allocation will take place: Box<MyThing> instead of MyThing. A heap
* allocation is more expensive to type and execute. It seems concious
* that there is no short hand for this. First consider dynamic dispatch:
*/

/*

fn a(b: &dyn B) {
    b.b();
}

/* where B is the trait a is abstract over.
 * Now the static dispatch version of the above:
 */

fn a<T: B>(b: T) {
    b.b();
}

// or alternatively
fn a<T>(b: T)
    where T: B {
        b.b();
    }

*/

fn knowitlabs() {
    test_something();
}



/*********************************************************************/

// Inject the depenency as a trait
// Call via method

use rand::Rng;

#[automock] // add to test
trait Readable {
    fn read_hw(&self) -> i32;
}

struct Sensor {}

impl Readable for Sensor {

    fn read_hw(&self) -> i32 {
        rand::thread_rng().gen_range(1,11)
    }

}

struct Speedometer {
    velocity:i32,
    // we remove the sensor, as we inject the dependency anyway
    //sensor:Sensor, 
    factor:i32,
}

impl Speedometer {

// old version
//    fn get_velocity(&self) -> i32 {
//        self.sensor.read_hw()
//    }

// old version needs to have the dependency injected
// we inject the dependency as a parameter that implements a trait
    fn get_velocity(&self, sens : &dyn Readable) -> i32 {
        sens.read_hw()
    }

}


fn test_speedo ()
{
    // So tut das aber nicht, weil die dependency nicht übergeben wird
    
    let mysensor = Sensor{};
    //let speedo =Speedometer{ velocity:0, sensor:mysensor, factor:5 };
    let speedo =Speedometer{ velocity:0, factor:5 };
    println!("Velocity is {}", speedo.get_velocity( &mysensor ));


    //add to test

    let mut mock_readable = MockReadable::new();

    mock_readable.expect_read_hw()
        .with()
        .times(1)
        .returning( || 42 );

    // funktioniert nicht !!!
    // println!("Velocity is {}", speedo.get_velocity());

    // Das hier ist nur dazu da, damit das mock aufgerufen wird
    // und der code durchläuft
    //println!("HW is is {}", mock_readable.read_hw());

    println!("Velocity is {}", speedo.get_velocity( &mock_readable ));
    
}

/*********************************************************************/

// Inject the depenency as a trait
// call via associated function

#[automock]
trait Readable2 {
    fn read_hw2(&self) -> i32;
}

struct Sensor2 {}

impl Readable2 for Sensor2 {
    fn read_hw2(&self) -> i32 {
        rand::thread_rng().gen_range(1,11)
    }
}

struct Speedometer2 {
    velocity2:i32,
    //sensor2:Sensor2, // I want this be a Readable2
    factor2:i32,
}

impl Speedometer2 {

    // This is now an associated function
    fn get_velocity2(sens2 : &dyn Readable2) -> i32 {
        // Issue the own sensor is negledted and the method is called on the trait
        sens2.read_hw2()
    }
}

fn test_speedo2 ()
{
    // this is the mocked sensor
    let mut mock_readable2 = MockReadable2::new();

    let mysensor2 = Sensor2{};

    //let speedo2 =Speedometer2{ velocity2:0, sensor2:mysensor2, factor2:5 };
    let speedo2 =Speedometer2{ velocity2:0, factor2:5 };

    mock_readable2.expect_read_hw2()
        .with()
        .times(1)
        .returning( || 42 );

    println!("Velocity2 is {}", Speedometer2::get_velocity2(&mock_readable2 ));
}

/*********************************************************************/

// Use a trait object Box<dyn Readable3 >
// Box<dyn Readable3 > is a stand in for any type that implements
// trait Readable3

#[automock]
trait Readable3 {
    fn read_hw3(&self) -> i32;
}

struct Sensor3 {}

impl Readable3 for Sensor3 {
    fn read_hw3(&self) -> i32 {
        rand::thread_rng().gen_range(1,11)
    }
}

struct Speedometer3 {
    velocity3:i32,
    // sensor3 the external dependency we like to mock
    sensor3: Box<dyn Readable3 >, // Trait object: Any sensor that implements Readable 3
    factor3:i32,
}

impl Speedometer3 {

    fn get_velocity3(&self) -> i32 {
        self.sensor3.read_hw3() * self.factor3
    }

    fn new (val:i32) -> Speedometer3{
        Speedometer3 {
            velocity3:0,
            sensor3: Box::new( Sensor3{} ),
            factor3: val
        }
    }
}

fn test_speedo3 ()
{
    // this is the mocked sensor
    let mut mock_readable3 = MockReadable3::new();

    mock_readable3.expect_read_hw3()
        .with()
        .times(2)
        .returning( || 43 );

    let speedo3 =Speedometer3{
        velocity3:0,
        sensor3: Box::new( mock_readable3 ),
        factor3:5 };

    println!("Velocity3 is {}", speedo3.get_velocity3( ));
    assert_eq!(speedo3.get_velocity3(), 215);
}

fn test_speedo3_normal_use_case_a ()
{
    let mysensor = Sensor3{};
    let speedo3 = Speedometer3 {
        velocity3:0,
        sensor3: Box::new( mysensor ),
        factor3:2
    };

    println!("Velocity use case b is {}", speedo3.get_velocity3( ));
}

fn test_speedo3_normal_use_case_b ()
{

    let speedo3 = Speedometer3 {
        velocity3:0,
        sensor3: Box::new( Sensor3{} ),
        factor3:2
    };

    println!("Velocity use case b is {}", speedo3.get_velocity3( ));
}

fn test_speedo3_normal_use_case_c ()
{

    let speedo3 = Speedometer3::new( 1 );

    println!("Velocity use case b is {}", speedo3.get_velocity3( ));
}


#[cfg(test)]
mod test_mod_speedo3 {

    use super::*;

    #[test]
    fn def_testspeedo3_a() {

        // Arrange
        let mut mock_readable3 = MockReadable3::new();

        mock_readable3.expect_read_hw3()
            .with()
            .times(1)
            .returning( || 45 );

        let speedo3 = Speedometer3{
            velocity3:0,
            sensor3: Box::new( mock_readable3 ),
            factor3:5 };

        // Act
        assert_eq!(speedo3.get_velocity3(), 225);

        // Assert
    }

    #[test]
    fn def_testspeedo3_annotated() {

        // Arrange

        // Create the mock
        let mut mock_readable3 = MockReadable3::new();

        // Configure the mock
        mock_readable3.expect_read_hw3()
            .with()
            .times(1)
            .returning( || 45 );

        // Crate our DUT
        let speedo3 = Speedometer3{
            velocity3:0,
            sensor3: Box::new( mock_readable3 ),
            factor3:5 };

        // Act: Call DUT

        let result = speedo3.get_velocity3();

        // Assert : Check further assertions

        assert_eq!( result, 225);
    }

}

/*********************************************************************/

fn main() {
    println!("Hello, mockall!");
    getting_started_mockall();
    //get_started_mock();
    examples();
    stackover();
    knowitlabs();
    test_speedo();
    test_speedo2();
    test_speedo3();
    test_speedo3_normal_use_case_a();
    test_speedo3_normal_use_case_b();
    test_speedo3_normal_use_case_c();

}
